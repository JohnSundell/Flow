# Flow

Flow is a lightweight Swift library for doing operation oriented programming.

You know how we always use flow charts, whiteboards and diagrams to explain how software works? Imagine if we could actually **write** software like that too. That’s what operation oriented programming is all about.

### Everything is an operation

Using Flow is all about splitting your code up into multiple atomic pieces - called `operations`. Each operation takes an `input` of a given type and produces an `output`, and should be able to operate independently of any other operation.

An operation can do anything, synchronously or asynchronously, and its scope is really up to you. The true power of operation oriented programming however, comes when you chain operations into logical sequences.

## How to use

1. Create operations by declaring objects conforming to `FlowOperation`.
2. Create logic sequences by using `FlowOperationChain`, and appending operations to form a chain.
3. Execute a chain by calling `performWithInput()`.

## Example

Let’s say we want to build an app that displays search results using the GitHub search web API. Whenever the user types in a search bar, we want to call the web API and render the results in a view.

This flow can be described as a `chain` of `operations`.

```
FlowOperationChain(rootOperation: InputHandlingOperation())
	.append(WebAPIOperation())
	.append(ModelOperation())
	.append(RenderingOperation())
```

Let’s implement these operations. First, `InputHandlingOperation` will take the string that the user typed and transform it into an `NSURL` that we can use to query the web API.

Creating an operation is as easy as conforming to `FlowOperation` and implementing `performWithInput(completionHandler:)`.

```
class InputHandlingOperation: FlowOperation {
    func performWithInput(input: String, completionHandler: NSURL? -> Void) {
        let baseAPIURL = "https://api.github.com/search/repositories?q="
        completionHandler(NSURL(string: baseAPIURL + input))
    }
}
```

Next up is the `WebAPIOperation`which will take the `NSURL` generated by the previous operation, call the web API, and output any `NSData` that was downloaded.
```
class WebAPIOperation: FlowOperation {
    func performWithInput(input: NSURL?, completionHandler: NSData? -> Void) {
        if let url = input {
            NSURLSession.sharedSession().dataTaskWithURL(url, completionHandler: {
                let data = $0.0
                
                dispatch_async(dispatch_get_main_queue(), {
                    completionHandler(data)
                })
            }).resume()
        } else {
            completionHandler(nil)
        }
    }
}
``` 

After we’ve downloaded our data, we need to unbox it and turn it into models. Here I’m going to use another open source library of mine, called [**Unbox**](http://github.com/johnsundell/unbox), which provides a simple way to decode JSON in Swift.

Let’s define our models:

```
struct SearchResult: Unboxable {
    let items: [SearchResultItem]
    
    init(unboxer: Unboxer) {
        self.items = unboxer.unbox("items")
    }
}

struct SearchResultItem: Unboxable {
    let title: String
    let description: String
    let url: NSURL
    
    init(unboxer: Unboxer) {
        self.title = unboxer.unbox("name")
        self.description = unboxer.unbox("description")
        self.url = unboxer.unbox("html_url")
    }
}
```

And our model operation:

```
class ModelOperation: FlowOperation {
    func performWithInput(input: NSData?, completionHandler: SearchResult? -> Void) {
        if let data = input {
            completionHandler(Unbox(data))
        } else {
            completionHandler(nil)
        }
    }
}
```

Time for the final operation, that takes the `SearchResult` model, and renders a representation of it in the User Interface. For now we’ll go with a super simple text view that just renders the data as text.

```
class RenderingOperation: FlowOperation {
    private let textView: UITextView
    
    init(textView: UITextView) {
        self.textView = textView
    }
    
    func performWithInput(input: SearchResult?, completionHandler: Void -> Void) {
        var text = ""
        
        if let result = input {
            for item in result.items {
                text += "TITLE: \(item.title)\nDESCRIPTION:\(item.description)\nURL:\(item.url)\n--------\n"
            }
        }
        
        self.textView.text = text
        completionHandler()
    }
}
```

And that’s it! We can now construct a chain of our operations and use it to perform all of them in sequential order. We’ll put the code to do so in our delegate callback from `UITextField`.

```
func searchBar(searchBar: UISearchBar, textDidChange searchText: String) {
    FlowOperationChain(rootOperation: InputHandlingOperation())
        .append(WebAPIOperation())
        .append(ModelOperation())
        .append(RenderingOperation(textView: self.textView))
        .performWithInput(searchText)
}
```

Done! We have now implemented a simple search app using operation oriented programming with Flow.

## But wait, why do this?

Organizing code into operations gives you several huge wins. Here are some of them:

### Testability
Since each operation takes a single input - and produces a single output - it’s super easy to test. In a unit test, you can give an operation a certain input - and then assert that the expected output is produced. No need for mocking, stubbing, or writing complicated test logic.

### Code reuse
Since an operation can’t make assumptions about what context it’s being used it, the code you write will automatically be very easy to reuse.

### Reduced complexity
You might end up writing slightly more code (or at least, have more classes) when using Flow, but since each operation has a single purpose and area of responsibility within your app, the net result will be a less complicated code base.

No more 1000+ line view controllers.

And with reduced complexity comes easier debugging, and several other benefits.

## API reference

**`FlowOperation`**
Used to declare operations that take an `Input` and produce an `Output` by calling a completion handler.

**`FlowOperationChain`**
Used to create logical chains of operations, that execute sequentially. The input of an operation in the chain is the output of the previous operation.

Create a chain with `FlowOperationChain(rootOperation:)` and then use `append()` to add additional operations to the chain. Finally, call `performWithInput()` to execute the chain.

**`FlowClosureOperation`**
An implementation of `FlowOperation` which enables you to create simple operations using a closure.

## Hope you enjoy using Flow!

For support, feedback & news about Flow; follow me on Twitter: [@johnsundell](http://twitter.com/johnsundell).

